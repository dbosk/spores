%!TEX root = p2p-private-cloud.tex

\subsection{The \squad overlay}
\label{sec:squad_overlay}

A user's devices communicate through an information dissemination protocol (coined \emph{e-squad overlay}) so as to learn the user's behavior.
The goal is twofold: 
devices need information on the user to predict their future availability, 
and they must know which device is responsible for which file exchange to route messages to their recipient in the \squad.

To achieve this goal, we adapt the Cascade protocol~\cite{luxey:cascade} to suit our needs. 
Using Cascade, participating nodes gossip in a push-pull manner: 
when a node has new information, it sends it to a fixed-size random subset of its peers; 
the recipients answer with any information that they believe the sender does not know about, thus reconciling their history.

The exchanged data forms a sequence, ordered by timestamp, populated by three types of information:
\begin{itemize}
	\item \texttt{CONNECTED<$d, t_{step}$>}: Sent by device $d$ when it is used by its user at time step\footnote{As far as devices connections are concerned, time is discretized: we consider that each interaction lasts the same time.} $t_{step}$. $d$ is otherwise considered offline at this time. Devices use this information to predict their probability of remaining online, as presented in section~\ref{ssec:device_availability};
	\item \texttt{SENDING<$d, ID_{file}$>}: When the user decides to send a file located on a device $d$, $d$ informs its peers of this fact, and joins the file ID $ID_{file}$. Squad members will use this information to forward acknowledgments from the remote to $d$;
	\item \texttt{RECEIVING<$d, ID_{file}$>}: Reciprocally, when the user starts receiving a file onto a device $d$, $d$ informs its peers of this fact, and joins the file ID $ID_{file}$. Squad members will use this information to forward the file's content from the remote to $d$.
\end{itemize}

Given this information dissemination and history reconciliation mechanism, each \squad member knows the full sequence $S$ at all time with an overwhelming probability, even in the face of churn.

\subsection{Predicting a device's availability}
\label{ssec:device_availability}

The predictive nature of \name lies in the fact that each participating device publicly advertises its probability of being connected in the near future. 
This information is used when any node needs to create a Probabilistic Onion Route (POR), as will be shown in the next subsection~\ref{ssec:por}.

As described earlier, \squad members know the connection times of all the user's devices, given by the \texttt{CONNECTED} items in the \squad's sequence.
It can be represented as a 2D sparse matrix of booleans, as shown in the Table~\ref{tab:connection_times} (depicting a user owning a laptop, a phone, and a smart-TV).


\begin{table}
\caption{Matrix representation of an \squad availability over time}
\centering
\begin{tabular}{@{}lccccc@{}} \toprule
		& $\cdots$	& $t_{i-1}$	& $t_i$		& $t_{i+1}$	& $\cdots$ \\ \midrule
Laptop	& $\cdots$	& 1			& 0			& 0			& $\cdots$ \\
Phone	& $\cdots$	& 1			& 1			& 1			& $\cdots$ \\
TV		& $\cdots$	& 0			& 1			& 1			& $\cdots$ \\ \bottomrule
\end{tabular}
\label{tab:connection_times}
\end{table}

To predict a device's future availability, we build a Markov representation of the user's activity, 
where the state $X_i$ represents the availability of the user's devices at time $t_i$.
The state space $\mathcal{X}$ is the set of possible combinations of the devices' connection.

Given the \squad sequence of connections $S = X_1, \dots, X_i, X_{i+1}, \dots$,
we can compute the probability of transition from a state $X_i=x$ to $X_{i+1}=x'$ by counting\footnote{%
	Because we work with low-probability events observed with a small amount of data, there is a possibility that an event never occurs in $S$. 
	To counter that, we apply additive smoothing while computing probabilities. 
	We left this engineering optimization out of the demonstration for clarity.
} the number of times $x'$ is seen right after $x$ in $S$:

\begin{align*}
P\left[X_{i+1}=x' \mid X_i=x \right] &= P\left[x \rightarrow x' \right] \\&= \frac{\left| \left\{ X_i = x, X_{i+1} = x' \right\}_{i \in \left[0, |S| - 1\right]} \right|}{\left| \left\{ X_i = x \right\}_{i \in \left[0, |S| - 1\right]} \right|}
\end{align*}

Each device knows the current state $X_i=x$ of the Markov chain.
To predict its probability $P_d$ of remaining online in the next round, 
a device $d$ simply adds the probabilities that the user switches to a state where $d$ is online next.
Consider $\mathcal{X}_{d\text{ online}} \subset \mathcal{X}$ the set of states where $d$ is online. Then:

\begin{align*}
P_d & = P\left[d\text{ online at }X_{i+1} \mid X_i=x\right] \\ & = \sum\limits_{x' \in \mathcal{X}_{d\text{ online}}} P\left[ X_{i+1}=x' \mid X_i=x \right]
\end{align*}

There is a caveat, though.
While the user acts, $S$ keeps growing, and the Markov chain must be recomputed: there is a probability that the current state $X=x$ has never been seen before.
In this case, $\forall x' \in \mathcal{X}, P\left[x \rightarrow x'\right]$ is undefined.

To counter this possibility, we propose a fallback:
when the current state is new, we compute a $P'_d$, an estimator of $d$'s average probability of staying online two turns in a row:

$$ P'_d = \frac{\left| \left\{ X_i \in \mathcal{X}_{d\text{ online}}, X_{i+1} \in \mathcal{X}_{d\text{ online}} \right\}_{i \in \left[0, |S| - 1\right]} \right|}{\left| \left\{ X_i \in \mathcal{X}_{d\text{ online}} \right\}_{i \in \left[0, |S| - 1\right]} \right|} $$

$P'd$ will be advertised in spite of $P_d$. It will also be used as a baseline in the evaluation.

\subsection{Probabilistic Onion Routes}
\label{ssec:por}

\commentAL{We need to merge \ref{SPOR} and this section.}

\subsubsection{The global overlay}
\label{sssec:global_overlay}

Devices need to know the address of SPORES participants in order to craft PORs.
To this end, we employ a Random Peer Sampling service~\cite{Jelasity_Voulgaris_Guerraoui_Kermarrec_van_Steen_2007} among all nodes in SPORES. \commentAL{TODO: cite \cite{Jesi_Montresor_van_Steen_2010} or else for \textbf{secure} RPS}.
It is a gossip protocol that allows each participant to keep a fixed-size \emph{random} subset of other nodes' descriptor (that we will call the \emph{view}). 
The view is constantly evolving, as queries are periodically issued between nodes to exchange descriptors between their respective views.
Finally, offline nodes are quickly evicted from devices' views.

The randomness of the views must be guaranteed: 
a node that would be present in views too often would become a bottleneck, and could monitor a bigger portion of the network.
It will be evaluated in section~\commentAL{TODO}.

In SPORES, a descriptor for $d$ contains the following information:
\begin{itemize}
  \item \(d\) is the node's identifier (address);
  \item \(\pk_d\) is the node's public key;
  \item \(P_d\) is the node's probability of remaining online at the time of the descriptor's creation.
\end{itemize}


\subsubsection{Routes creation}
\label{sssec:routes_creation}



\subsection{SPORES: file exchange through probabilistic onion routes}
\label{ssec:spores_file_exchange_through_probabilistic_onion_routes}

\newcommand\finfo{\ensuremath{\mathcal{I}_f}}
\newcommand\filesize{\ensuremath{s_f}\xspace}
\newcommand\chunksize{\ensuremath{s_{\text{chunk}}}\xspace}
\newcommand\nchunks{\ensuremath{n_{\text{chunks}}}\xspace}
\newcommand\hashchunk{\ensuremath{\mathcal{H}_{\text{chunk}}}\xspace}
\newcommand\hashfile{\ensuremath{\mathcal{H}}\xspace}

We have seen how participants of \name could craft routes to secretly exchange messages.
We now apply this feature to reliably exchange files between two users.

Our file transfer protocol is loosely based on BitTorrent \cite{bt_bep3}: 
at initialization, a file $f$ of size \filesize is first cut into chunks of constant size \chunksize by its uploader,
resulting in $\nchunks = \lceil \filesize / \chunksize \rceil$ chunks.
A SHA1 hash \hashchunk is computed for each chunk, plus another SHA1 hash \hashfile of the chunks hashes ; that will serve error detection. 


In BitTorrent, .torrent files are publicly available on the Web.
They contain $\finfo = \left(\filesize, \nchunks, \left[\hashchunk\right]_{\text{chunk} \in f}, \hashfile\right)$, 
along with network information to reach uploaders of $f$ (e.g. the tracker's address).
Anyone can download a .torrent file and start receiving the file associated to it.
In \name, we want file exchanges to remain private: these metadata are exchanged out-of-band.

\paragraph{Out-of-band initialization} 
When Alice wishes to send a file to Bob, she 
