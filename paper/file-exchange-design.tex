\subsection{Scheduling and transferring a file}%
\label{sec:file_exchange}

We are interested in transferring large files.
Every device \(d\in D\) in the global device swarm is only periodically online.
We will thus divide the data to send into \(n\) smaller chunks (similar to 
BitTorrent~\cite{BitTorrent}).
The idea is to choose \(n\) such that each chunk will be small enough to be 
successfully relayed by a device before it goes offline again.
The chunk size is empirically determined in \cref{Performance}.
\commentDaniel{Adrien, is that true?}

As stated above, Alice and Bob exchange some limited data out-of-bound using 
their smartphones.
The information they will exchange is the following:
\begin{enumerate}
  \item Bob creates an onion route header, \(H_\rdv\), by running 
    \([\Recv]\) %(\cref{SPORFwd}) 
    and gives it to Alice.
  \item Alice gives Bob number of file chunks, \(n\), and the size of the file 
    chunks.
  \item They agree on a file-specific key \(k\) for some (authenticated) 
    encryption scheme \(\Enc*\).
\end{enumerate}
Then Alice encrypts the file \(f\) and receives the ciphertext \(c_f\gets 
  \Enc*[Enc](k, f)\).
She then divides \(c_f\) into \(n\) chunks, \(c_f^{(1)}, \dotsc, c_f^{(n)}\), 
and runs \(\Send(H_\rdv, c_f^{(i)})\) for all \(1\leq i\leq n\) in 
parallel.
\commentDaniel{Or shall we do it sequentially?}