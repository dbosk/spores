\section{Security Discussion}%
\label{security-discussion}

Alice wants to prevent Bob from learning which are her devices (as defined in 
\cref{system-model}).
Bob is allowed to infer the behaviour of devices in the Global Device Retinue, 
but a file transfer from Alice should not give Bob any information about which 
devices are Alice's.

Bob constructs \iac{SPOR} route that he gives to Alice.
This means that Alice does not learn any of Bob's destination devices.
When Alice starts sending the message, she will not connect directly to the 
device at the head of the route, since that might be Bob's device.
Alice will construct her own \ac{SPOR} route.
Thus Alice's devices are hidden from Bob's observation and vice versa.
If we assume that Alice and Bob can sample their nodes uniformly randomly from 
the \emph{entire} Global Device Retinue (we will return to this assumption 
below), then their probability of successful attack is proportional to their 
size in the network, \ie \(\frac{|D_i|}{|D|}\), for \(i\in \{a,b\}\).

Alice and Bob also want to prevent Carol and David to learn that Alice sent a 
message to Bob (as defined in \cref{system-model}).
Alice and Bob construct their \ac{SPOR} route by including devices from the 
Global Device Retinue, which also includes devices from Carol and David.
If all devices on the route belong to Carol and David, then they can, of course, 
learn that Alice sent a message to Bob.
How well they can do if they do not control the entire route, depends on the 
choice of the encryption scheme \(\Enc*\), used to encrypt the message \(m\) 
(see \cref{sec:file_exchange}).

What makes sense is to choose at least an authenticated encryption 
scheme~\cite{AuthEncryption}.
(We could also choose a deniable encryption scheme~\cite{DeniableEncryption}, 
\eg the one by \textcite{OTPKX} which is both deniable and authenticated and 
provides \ac{DEN-SS}.)
This would give confidentiality (or deniability) and integrity for the message, 
but if the first and the last node belong to Carol and David, they can infer 
that Alice sent a message to Bob.
Note that as our in-package header is designed, each node on the route can infer 
its position on the route \emph{relative to the destination}.
(We discuss how to remedy this below.)
None of the nodes can know if the previous node is the originator or not, unless 
they collude with the previous node.
The last node, however, can know for sure that the next hop is the destination, 
but not who it belongs to.

If we choose \(\Enc*\) as a universal re-encryption~\cite{UniversalReencryption} 
scheme (possibly composed with the deniable, authenticated encryption above), 
then we could also provide bitwise unlinkability for the message between hops on 
the route.
(We would also need to modify \(\SPOR[\Fwd]\), \cref{SPORFwd}, to perform the 
re-encryption of \(m\) before forwarding the message to the next hop.)
Without universal re-encryption, the message \(m\) itself remains constant 
throughout the route and thus constitutes a tag for tracking.
As long as \emph{at least one node on the route is honest}, \ie actually 
performs the re-encryption --- there is no incentive for them to do this, as 
neither Alice nor Bob can detect cheating without talking directly to each other 
to compare the ciphertexts --- then the link between Alice and Bob is broken.
This means that Carol and David must control all nodes on the route to link 
Alice's transfer to Bob.
As above, if we assume uniformly random peer sampling, then Carol and David's 
success probability is proportional to their joint size in the network.

This means that under the assumption of uniformly random peer sampling, we 
achieve the properties we outlined in \cref{system-model}.
Additionally, since Alice and Bob choose a new key for every file, we have 
forward secrecy between files.
\Eg an adversary who compromises either Alice or Bob cannot determine what Alice 
sent to Bob, unless it is an ongoing transfer.

\subsection{Limitations}%
\label{security-limitations}

Many attacks against anonymous communications systems target the peer sampling 
mechanism, \eg~\cite{%
  RouteFingerprinting,%
  EpistemicAttacksOnRouteSelection,%
}.
So, even if our system is secure in theory, it will not be secure in practice 
unless the random peer sampling algorithm returns peers chosen uniformly 
randomly from the entire Global Device Retinue.

To prevent attacks on the random peer sampling, some systems have employed 
techniques to detect colluding nodes, \eg~\cite{%
  SecurePeerSampling,%
  MorphMix,%
}.
However, as is the case of~\cite{MorphMix}, these can be 
broken~\cite{BreakingMorphMix}.

There are also other types of attacks, \eg denial of service attacks that can 
lead to the adversary learning more from the system~\cite{DenialOfSecurity}.
It is difficult to say to what extent our system might be vulnerable to this 
type of attack without a deeper analysis.
Unfortunately this is outside the scope of this study.
However, we hypothesize that our stateless and redundant design might have some 
advantages, \eg no control messages sent back from where the error happened to 
the source.
But these advantages will only postpone the success of the attack, eventually 
even our protocol must resend.

\subsection{Future Work}

One thing that we can directly improve is the header.
We see two alternative paths for improving the header.
First, we might be able to adapt the Sphinx~\cite{Sphinx} cryptographic packet 
format to the routing of \(\SPOR\).
Then we could achieve the properties of Sphinx, \eg preventing the last node to 
learn the destination, and enjoy provable security.

The second approach would be to use the technique by \textcite{PPACinPubFS}.
They adapt \(\ANOBE\) in such a way that its ciphertexts decrypt to different 
things for different recipients.
This way we could have one ciphertext encrypted for all the alternative nodes 
--- across layers.
Then the ciphertext would decrypt to different plaintexts for nodes on different 
layers in the route.
This would hide the path length (constant-size ciphertexts by padding) and the 
position of individual nodes.
This approach would probably be the easiest, but would probably not provide all 
the properties from Sphinx (\eg resistance to active tagging attacks).
