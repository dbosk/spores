\section{Security Discussion}%
\label{security-discussion}

\sonja{will add some framing about us composing and modifying parts that
  have security proofs for their original and individual versions and needing to evaluate the resulting schemes}

\commentDaniel{Predecessor attacks: random walk protocols has the problem that 
  the adversary can see the initiator (statistically) more often than the other 
  nodes, and can thus identify the 
  source~\cite{RoutingSurveyAnonymousProtocols}.
  Our protocol is a \enquote{bounded} random walk, \ie within limits.}

We base our solution on Sphinx, which, when used for onion routing, has been proved to satisfy the
properties given in ~cite{CLOnionRouting} that were shown to result
in a UC-secure onion-routing scheme. We thus primarily need to ensure that 
\begin{enumerate*} \item our extension to Sphinxes preserves these
  properties, \item the availability information introduced and
  disseminated to deal with churn satisfies the device-unlinkability
  property we defined in~\cref{system-model}, and that \item the node
  selection does not introduce any advantage for the
  adversary. \end{enumerate*} In terms of general system robustness, a
stateless routing protocol needs to handle packet re-ordering and
network failures (links or nodes). 

\paragraph*{Security of Sphinxes}

There are two changes that we have made that must be analysed.
We changed the key agreement from a pure \ac{DHKE}, \ie based on the \ac{DH} 
assumption, to one containing an indirection.
We also changed from the classical \ac{OR} of a fixed path with one node per 
layer to \ac{POR} with several nodes per layer.

The confidentiality of the key previously rested entirely on the \ac{DH} 
assumption (\(\alpha\) in the header).
Now it also rests on the security of the \ac{PRP} \(\prp'\) (\(C\) in the 
header).
The integrity is still reduced to the security of the \ac{MAC} \(\mac\) 
(\(\gamma\) in the header).

The second change is that we use several nodes per layer as opposed to only 
one.
The proofs of Sphinx rests on the results of \textcite{CLOnionRouting}, which 
are results for ordinary \ac{OR} with only one node per layer.
As long as we output all the nodes in the next layer, the proofs should not 
change.
We note that this is actually quite natural as a malicious adversary can drop 
any incoming traffic to a router and wait for the timeout and retransmission to 
the next node.
As such, the adversary can learn all nodes in the layer.

With these arguments, we believe that Sphinxes inherits the \ac{UC} security 
properties of Sphinx, however, this should be formally analysed.

\paragraph*{Security of \acs*{SPOR}}

The onion route provides unlinkability between Alice and Bob as long as the 
message passes at least one honest node on the route.
This means that any adversary, say Eve,  must ensure that the message passes 
through an adversarial node on each layer.
The probability of successful attack is proportional to Eve's size in the 
network, \ie \(f_A = \frac{|D_A|}{|D|}\).
\commentDaniel{Check that we still use the \(D_i\) notation for the devices in 
  \(i\)'s squad.}
If we assume that \(\GetRandomNode\) returns nodes with close to the uniform 
distribution, then the \(\nu w_L\) nodes selected will contain \(f_A \nu w_L\) 
nodes controlled by Eve.
If \(f_A \nu w_L < \nu\), then Eve cannot be present on every layer of the 
route.
Considering how \ac{SPOR} distributed the \(\nu w_L\) selected nodes, Eve's 
best strategy is to have high-availability nodes --- assume that 
\(\avail_{D_E}(t) = 1\) for all Eve's devices \(D_E\).
This way, Eve's devices will be distributed evenly across all layers.
To succeed, Eve must be chosen in the first layer, the probability of which 
will be \(\frac{f_A}{w_L}\).
If one of her devices is chosen in the first layer, then she can choose one of 
her own devices in the next layer.
Since she is present on every layer, she can ensure she relays the message all 
the way to Bob.

However, Eve can only be certain that she has relayed the message from Alice to 
Bob if \(\nu = r\), \ie she receives the message from Alice, relays it \(r-1\) 
times and lastly sends it to Bob.
If \(\nu < r\) though, then, due to the indistinguishability and unlinkability 
properties of Sphinxes (inherited from Sphinx), Eve cannot know for certain if 
Alice is the first node and Bob is the last node.

\paragraph*{Limitations}%
\label{security-limitations}

A global, passive, network-observing adversary can of course do statistical 
disclosure attacks to eventually learn who communicates with 
whom~\cite{StatisticalDisclosureAttacks}.
There are also denial of service attacks that can lead to the adversary 
learning more from the system~\cite{DenialOfSecurity}.
It is difficult to say to what extent our system might be vulnerable to this 
type of attack without a deeper analysis.
Such an analysis is out of scope of this analysis, here our focus is to protect 
Alice and Bob from each other and their friends who also participate as nodes 
in the network, not to protect them from \eg the \ac{NSA}.
However, we hypothesize that our stateless and redundant design might yield 
some advantages, \eg no control messages sent from where the adversary have 
introduced an error back to the source.
But these advantages will only postpone the success of the attack, eventually 
even our protocol must resend.
\commentDaniel{We should look into this denial of security.}

Finally, we must point out that the \(\GetRandomNode\) algorithm must be 
privacy preserving.
Consider the following scenario.
Alice requests a set of peers, say \(\{d_1, \dotsc, d_n\}\).
If \(d_i\) interacts in each sampling operation resulting in \(d_i\) being in 
the sample, then \(d_i\) can generate a new public key \(\pk_d^{(j)}\) for each 
sample \(j\).
This means that, if Alice sampled \(d_i\), she knows the public key 
\(\pk_i^{(j)}\), and if \(d_i\) knows it is included in Alice's sample, then it 
will also know a route belongs to Alice whenever \(\pk_i^{(j)}\) is used to 
encrypt the header.
(This follows from the fact that Sphinxes is source-routed.)
\Ie every node on Alice's route would know that Alice is either the source or 
the destination.

\paragraph*{Robustness}

Stateless routing can result in re-ordered chunks or packets, and
chunks received on different devices of a user's squad. From
Sphinx, we inherit IDs for packets that we we include in the
out-of-band metadata on the file to be exchanged, as an ordered list,
that is used to re-order chunks if need be. The squad overlay handles
inter-squad device coordination. Liveness despite the possibility of squad devices going offline during
transfer or other node or link failures is ensured by acknowledgments
and timeouts as detailed in ~\cref{sec:squad_overlay}.




