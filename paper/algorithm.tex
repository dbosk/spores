\section{Algorithm}%
\label{Algorithm}

Alice and Bob each has a set of devices containing their files, \eg a 
smartphone, laptop and a desktop computer.
Alice and Bob meet in a cafÃ© carrying only their smartphones and Alice wants to 
share a file, \(f\), with Bob.
Alice's smartphone knows some metadata of \(f\) and that it resides on Alice's 
desktop computer.
She gives some metadata about \(f\) to Bob, at least the file size.
Bob creates an onion route of low-availability devices with some subset of Bob's 
devices as the destination.
The layers of the route are chosen such that the probability of all devices 
being offline at the same time is low.
Bob gives this route to Alice.
Alice's smartphone ensures that her desktop computer (containing the file \(f\)) 
gets the route and the instruction to send \(f\) using this route.
When Alice's desktop computer receives this instruction it will create the first 
half of the route and concatenate it with Bob's route, then transfer \(f\) to 
Bob.
In this section we will present the details of the necessary algorithms.

We have a set of users, \(U\), each user \(u\in U\) has a set of devices, 
\(D_u\).
We call \(D_u\) the device swarm of \(u\).
Alice, \(a\in U\), has a device swarm, \(D_a\), and Bob, \(b\in U\) has a device 
swarm, \(D_b\).
We let \(D = \cup_{u\in U} D_u\) be the set of all devices, the global device 
swarm.

Without loss of generality, we will use Alice and Bob as examples.
Each of Alice's (and Bob's) devices will keep track of its own online and 
offline behaviour.
They will use a protocol like Sprinkler~\cite{luxey:hal-01704172} to learn about 
each other's online--offline behaviour.
\commentDaniel{Is that correct?}
This allows Alice's device swarm to do internal scheduling.

Each device \(d\in D_a\) will also participate in the global device swarm, 
\(D\supset D_a\).

\subsection{Adrien's old stuff}

\newcommand{\localoverlay}{Local Overlay\xspace}
\newcommand{\globaloverlay}{Global Overlay\xspace}

\subsection{The \localoverlay}%
\label{local-overlay}

A user's devices, \(D_i\), use the \localoverlay to:
\begin{enumerate}
	\item Share information about the user's behavior.
	Devices use it to build a behavioral model and infer their future connection probability;
  \item Share files location \commentAL{Maybe \dots}
\end{enumerate}

\subsubsection{Sharing the user's behavior}% (fold)
\label{ssub:sharing_the_user_s_behavior}

Each device initially only knows when it is connected. 
To make a model of the user's behavior, they need to know the whole observation sequence $O$: which device is online at each time step.
To do so, they employ a probabilistic dissemination protocol, 
\textsc{Sprinkler}~\cite{luxey:hal-01704172}.
This allows devices to gossip any new connection information to random peers in 
the local swarm, ensuring that all devices know the full observation sequence 
with a very high probability.
\textsc{Sprinkler} has shown resilient to device churn~\cite{luxey:cascade}, and 
is thus perfectly suited for our purpose, where a user's devices often 
disconnect and reconnect. 

\commentAL{Then we \textbf{maybe} do predictions as \textbf{maybe} shown in 
  \cref{sec:user_model}.}


% subsubsection sharing_the_user_s_behavior (end)

\subsubsection{Sharing files location}% (fold)
\label{ssub:sharing_files_location}

We do stuff and things work.

% subsubsection sharing_files_location (end)

\subsection{The \globaloverlay}%
\label{global-overlay}

Every time a device is online, it participates in the random peer sampling 
protocol.
If a device is sampled it provides the following information:
\begin{itemize}
  \item its address;
	\item its public key;
  \item the probability of being online.
\end{itemize}

\subsection{The file exchange}%
\label{file-exchange}

\subsubsection{File exchange process}% (fold)
\label{ssub:file_exchange_process}

Firstly, Alice and Bob must exchange information out-of-band: an encryption key $ek$ to cipher the file, and an ID $k$ in the DHT pointing to information on how to reach Alice.

\subsection{Random peer sampling and predictions}

\commentDaniel{%
  We must cover how to do \(\Pr[d \text{ offline at time } t]\) as used in 
  \cref{ExtendRoute}.
  This is probably part of getting random peers in the same place.%
}

\commentDaniel{%
  What is the probability distribution of the peer sample that we get?
  Will it be close to uniformly random?%
}

\NewScheme{\SPOR}{SPOR}

\subsection{\(\SPOR\): Stateless Predictive Onion Routing}

\NewAlgorithm{\Send}{Send}
\NewAlgorithm{\Fwd}{Forward}
\NewAlgorithm{\Recv}{Receive}
\NewVariable{\rdv}{rdv}

We have the Stateless Predictive Onion Routing scheme, \SPOR, which provides 
probabilistically onion-routed message passing.
Instead of providing only one address per hop in the route (as in \eg 
Tor~\cite{Tor}), \(\SPOR\) provides several alternatives for the next hop 
depending on their probability of being online.
To do this, \(\SPOR\) provides stateless algorithms for the onion-routing.

\(\SPOR\) provides three algorithms: \(\SPOR[\Send]\) (\cref{SPORSend}), 
\(\SPOR[\Fwd]\) (\cref{SPORFwd}) and \(\SPOR[\Recv]\) (\cref{SPORRecv}).
Say Alice wants to send a message \(m\) to Bob.
Bob uses \(\SPOR[\Recv]\) to create a probabilistic onion route \(H_\rdv\) from 
a rendez-vous point to his own device swarm --- all the hops on the route are 
chosen by Bob uniformly at random.
Bob gives \(H_\rdv\) to Alice using an out-of-band channel, \eg using his phone.
Alice uses \(\SPOR[\Send]\) at some later time to send the message to Bob using 
any of her devices.
\(\SPOR[\Send]\) extends the route \(H_\rdv\) with some hops of Alice's choosing 
(uniformly randomly chosen), then starts to forward the message (using 
\(\SPOR[\Fwd]\)) through the hops on the route to Bob.
This process is illustrated in \cref{fig:file-exchange}.

\begin{figure}
  \includegraphics[width=\linewidth]{figures/file_exchange.pdf}
  \caption{\label{fig:file-exchange}%
    A schematic of Alice and Bob sending a message using \(\SPOR\).
  }
\end{figure}

\NewAlgorithm{\ExtendRoute}{ExtendRoute}
\NewAlgorithm{\GetRouteNode}{GetRouteNode}
\NewAlgorithm{\GetRandomPeer}{GetRandomPeer}

\NewAlgorithm{\Enc}{Enc}
\NewVariable{\pk}{pk}

\begin{figure}
  \begin{algorithmic}
    \Require{%
      $H$ is a header of the form \(D\concat H'\) or \(D\concat \top\), where 
      \(D\) is a set of device addresses.
      $\pk_D$ is the public key of device set $D$.
      $L$ is the length of the route,
      $\theta$ is the threshold of probability of failure.%
    }
    \Function{\ExtendRoute}{$H, L, \theta$}
      \If{$L\leq 0$}
        \State \Return $H$
      \EndIf
      \State $D\gets \GetRouteNode[\theta]$
      \State $H\gets D\concat \Enc[_{\pk_{D}}][H]$
      \State \Return $\ExtendRoute[H, L-1, \theta]$
    \EndFunction

    \Function{\GetRouteNode}{$\theta$}
      \State $D\gets \GetRandomPeer$
      \While{$\prod_{d\in D} \Pr[d \text{ offline at time } t] > \theta$}
        \State $D\gets D\cup \GetRandomPeer$
      \EndWhile
      \State \Return $D$
    \EndFunction
  \end{algorithmic}
  \caption{\label{ExtendRoute}%
    The \(\ExtendRoute\) algorithm extends a route \(H\) with \(L\) hops and 
    failure threshold of \(\theta\) for each hop in the route.
    Thus the probability of failure for the extension is \(1 - (1 - \theta)^L\).
    The function \(\GetRandomPeer\) is any random peer-sampling algorithm.
  }
\end{figure}

\NewAlgorithm{\Store}{Store}
\NewAlgorithm{\Dec}{Dec}
\NewVariable{\sk}{sk}

\begin{figure}
  \begin{algorithmic}
    \Require{%
      $D$ is the set of alternative recipient devices.
    }
    \Function{\SPOR[\Recv]}{$D$}
      \State $H_\rdv\gets \ExtendRoute[D\concat \top, L, \theta]$
      \State \Return $H_\rdv$
        \Comment{Give to sender out-of-bound.}
    \EndFunction

    \Function{\Store}{$c_m$}
      \State $m\gets \Dec[_{\sk_D}][c_m]$
      \If{$m = \bot$}
        \State \Return $\bot$
      \EndIf
      \State Store $m$ to disk.
      \State \Return $\top$
    \EndFunction
  \end{algorithmic}
  \caption{\label{SPORRecv}%
    The \(\SPOR[\Recv]\) algorithm prepares the recipient for receiving a file.
    It creates a probabilistic onion-route from a rendez-vous point to its own 
    devices and returns the route to the sender.
    The \(\Store\) algorithm is used by the local \(\SPOR[\Fwd]\) algorithm to 
    store messages intended for itself.
  }
\end{figure}

\begin{figure}
  \begin{algorithmic}
    \Require{%
      $m$ is the message to be sent,
      $\pk_D$ is the public-key of the recipient,
      $H_\rdv$ is the onion-route given by the recipient.
    }
    \Function{\SPOR[\Send]}{$m, \pk_D, H_\rdv$}
      \State $H\gets \ExtendRoute[H_\rdv, L, \theta]$
      \State $c_m\gets \Enc[_{\pk_D}][m]$
      \State $D\concat C_H\gets H_\rdv$
      \For{$d\in D$}
        \Comment{Uniformly randomly chosen}
        \If{$d\method \Fwd[C_H, c_m] \neq \bot$}
          \State \Return $\top$
        \EndIf
      \EndFor
      \State \Return $\bot$
    \EndFunction
  \end{algorithmic}
  \caption{\label{SPORSend}%
    The \(\SPOR[\Send]\) algorithm extends the route \(H_\rdv\) (using 
    \(\ExtendRoute\), \cref{ExtendRoute}) and sends the message \(m\) down the 
    extended route using the \(\SPOR[\Fwd]\) algorithm (\cref{SPORFwd}).
    The first node of \(H_\rdv\) is the rendez-vous point selected by the 
    recipient.
    \(\pk_D\) is the public key of the recipient.
  }
\end{figure}

\begin{figure}
  \begin{algorithmic}
    \Require{$\pk, \sk$ is the public--private key-pair of the node.}
    \Function{\SPOR[\Fwd]}{$C_H, c_m$}
      \State $H\gets \Dec[_\sk][C_H]$
      \If{$H = \bot$}
        \State \Return $\bot$
      \EndIf
      \State $\{d_i\}\concat C_H'\gets H$
      \If{$C_H' = \top$}
        \State \Return $\Store[c_m]$
      \EndIf
      \For{$d\in \{d_i\}$}
        \Comment{Uniformly randomly chosen}
        \If{$d\method \Fwd[C_H', c_m] \neq \bot$}
          \State \Return $\top$
        \EndIf
      \EndFor
      \State \Return $\bot$
    \EndFunction
  \end{algorithmic}
  \caption{\label{SPORFwd}%
    The \(\SPOR[\Fwd]\) algorithm forwards \(c_m\) down the route \(H\), 
    obtained by decrypting \(C_H\) with the node's associated private key.%
    The special value \(H = \top\) indicated the end of the route, thus \(c_m\) 
    is intended for the local node and \(c_m\) is instead sent to disk using 
    \(\Store\) (\cref{SPORRecv}).%
  }
\end{figure}

\subsection{Scheduling a file transfer}

\commentDaniel{%
  We must do the scheduling: \ie divide the file \(f\) into \(f_1, \dotsc, f_n\) 
  and how the size of \(f_i\) relates to transmission time and size of the 
  timeslot (for the validity of predictions).
  After that we just do \(\SPOR[\Send]\) on each \(f_i\).%
}


\endinput

% subsubsection onion_routes_in_face_of_churn (end)

% \begin{figure}[t]
% \centering
% \includegraphics[width=0.8\columnwidth]{figures/schema.pdf}
% \caption{\label{fig:pipeline}Pipeline of the steps undergone by Alice when he shares a file from his laptop L with Bob.}
% \end{figure}

% \Cref{fig:pipeline} depicts the process of a file exchange from Alice to Bob.
% The file $f$ is initially located on Alice's laptop $L$, which is potentially offline for now.
% Firstly, Alice and Bob need to exchange encryption keys and the key $ID_f$ 
% referencing the file on the \ac{DHT}.
% They do so \emph{out-of-band}, that is using another channel than the one 
% presented here (\eg bluetooth, email, \etc).

% Then, Alice queries the DHT for devices that will most likely be online at the same time as his laptop $L$.
% To this end, Alice uses his knowledge on his devices connection patterns $A_i$, along with the DHT's public information on devices connections.
% Once Alice and the DHT agreed upon a set of peers $(M_1, M_2, M_3)$, their address is put in the DHT at the key $ID_f$ referencing the file of interest.

% At the third step, Alice's laptop $L$ becomes available. 
% Informed of the ongoing file exchange by Alice's Device Swarm Protocol, $L$ fetches the addresses of $M_1, M_2$ and $M_3$ on the DHT using the key $ID_f$.
% These peers will serve as middle-men: $L$ sends them redundant chunks of $f$ through an onion route (thus remaining anonymous), for Bob to fetch them later.

% In the last forth step, Bob fetches the file $f$ using any of her devices.
% To do so, she uses the key $ID_f$ to learn the addresses of $M_1, M_2$ and $M_3$.
% Then, she fetches parts of $f$ from the online middle-men through an onion route.
% Given that $L$ sent redundant chunks to the middle-men, Bob will not need every middle-man to be connected to fetch the whole file.
% Once Bob has completed the download, the key $ID_f$ is flushed on the DHT.
