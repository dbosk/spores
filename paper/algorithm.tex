\section{Algorithm}%
\label{Algorithm}

\NewCryptoEntity{\Alice}{A}
\NewCryptoEntity{\Bob}{B}
\NewCryptoEntity{\Carol}{C}
\NewCryptoEntity{\David}{D}

We have several participants: Alice, Bob, Carol and David.
Each of them has a set of devices, \(D_i\) (where \(i\in \{\Alice, \Bob, \Carol, 
  \David\}\)).
We have two protocols to track knowledge: one protocol which is run between the 
devices in \(D_i\) (the Device Swarm Protocol) to keep local knowledge in the 
swarm and another run between different swarms (the Inter-Swarm Protocol) to 
keep global knowledge.
Finally, we have a file-sharing protocol which uses the local and global 
knowledge to coordinate file sharing between devices in different swarms.

\subsection{The Device Swarm Protocol}%
\label{DeviceSwarmProtocol}

A user's devices, \(D_i\), uses the Device Swarm Protocol to coordinate 
themselves.
More specifically, the devices use this protocol to keep the swarm state up to 
date.
The swarm state contains:
\begin{itemize}
  \item A knowledge vector, \(K_i\), encoding a Markov chain to predict online 
    and offline patterns for the various devices to predict when and for how 
    long each device might be available before disappearing again.
  \item A table, \(F_i\times \powerset(D_i)\), mapping a user's files (\(F_i\)) 
    to its devices (\(D_i\)) that store a copy of it.
\end{itemize}

\commentDaniel{What should we reuse from the session-handoff paper?}

\subsection{The Inter-Swarm Protocol}%
\label{InterSwarmProtocol}

All swarms participates in the Inter-Swarm Protocol to coordinate the global 
knowledge needed by the swarms to interact.
More specifically, the global knowledge contains:
\begin{itemize}
  \item A table, \(A\), of available devices.
  \item A key--value store, \(S = \{0, 1\}^\lambda\times \{0, 1\}^*\), mapping 
    fixed-length strings of length \(\lambda\) to arbitrary-length strings.
\end{itemize}

\subsection{File-sharing protocol}

\dots
