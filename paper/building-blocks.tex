\section{Building blocks}%
\label{BuildingBlocks}

\dots

\subsection{\Aclp*{KEM}}\label{KEM}

\dots

\subsection{\Acl*{BE}}\label{BE}

We will do onion routing with many alternative nodes per hop.
This means that we encrypt the same message for more than one possible 
recipient.
Given this, it is natural to look for a suitable \ac{BE} scheme.
More specifically, we are interested in \iac{BE} scheme adapted for \iac{P2P} 
setting, where devices can dynamically join and leave --- \ie we do not want too 
much cost for joining or leaving, \eg from key regeneration.
We also want some privacy properties, \eg those of \ac{ANOBE}.

\NewScheme{\ANOBE}{ANOBE}
\NewAlgorithm{\ANOBEsetup}{\ANOBE\method Setup}
\NewAlgorithm{\ANOBEjoin}{\ANOBE*\method Join}
\NewAlgorithm{\ANOBEleave}{\ANOBE*\method Leave}
\NewAlgorithm{\ANOBEenc}{\ANOBE\method Enc}
\NewAlgorithm{\ANOBEdec}{\ANOBE\method Dec}

Our \ac{P2P} setting requires something similar to \iac{DBE} scheme.
However, we want a slightly different definition.
We say that \iac{BE} scheme is \iac{DeBE} if
\begin{enumerate}
  \item the setup is independent from the expected number of users or an upper 
    bound thereof,
  \item a new user can join at any time and the already issued decryption keys 
    can remain the same,
  \item the previous (public) encryption key can still be used if the newly 
    joined user is not in the recipient set.
\end{enumerate}
Unlike the definition of \textcite{DynamicBroadcastEncryption}, we desire 
forward secrecy --- in our scenario it makes no sense that new devices can 
decrypt old ciphertexts.
We also want to change the restriction on the ciphertext size:
whereas \textcite{DynamicBroadcastEncryption} require the ciphertext size to be 
independent from the expected number of users, we want it to be independent of 
the total number of users --- \ie it can depend on the recipient set.
In this sense, the trivial \ac{BE} scheme would fulfil our definition, but not 
the definition of dynamic~\cite{DynamicBroadcastEncryption}.

% XXX Deal with self plagiarism here: \cite{PPACinPubFS}

\(\ANOBE\) provides the following algorithms:
\ANOBEsetup,\allowbreak \ANOBEjoin,\allowbreak \ANOBEenc,\allowbreak \ANOBEdec.

The \(\ANOBEsetup\) algorithm generates the global parameters.
The \(\ANOBEjoin\) algorithm performs necessary key generation and other 
operations when a device joins.
The \(\ANOBEenc\) algorithm takes a message and a recipient set \(S\) and returns 
a ciphertext that everyone in \(S\) can decrypt using \(\ANOBEdec\).

\NewScheme{\ANOBE}{ANOBE}
\NewAlgorithm{\ANOBEsetup}{\ANOBE\method Setup}
\NewAlgorithm{\ANOBEkeygen}{\ANOBE\method Keygen}

We can use the \(\ANOBE\) scheme by \textcite{ANOBE} to instantiate our 
decentralized version.
We simply have to break \(\ANOBEsetup\) and \(\ANOBEkeygen\) into 
\(\ANOBEsetup,\allowbreak \ANOBEjoin\).

\endinput

\(\ANOBEsetup\) generates a master public key \(MPK = (\S*, \{\PubKey{i}\}_{i\in
    U})\) and the master secret key \(MSK = \{\PriKey{i}\}_{i\in U}\), where 
\((\PubKey{i}, \PriKey{i})\rgets \E*[Keygen][1^\lambda]\).
\(\ANOBE[Keygen][MPK, MSK, i]\) simply returns \(\PriKey{i}\) from \(MSK\).

For encryption, we must first generate a one-time signature key-pair 
\((\SignKey{}, \VerifKey{})\), then we choose a random permutation \(\pi\colon 
  R\to R\).
Next we must encrypt the message \(m\) and the verification key \((m, 
  \VerifKey{})\) for every user \(i\in R\) in the recipient set \(R\subseteq 
  U\) under their respective public key, \(c_{i} = \E*[Enc][\PubKey{i}, 
  m\concat \VerifKey{}]\).
We let the \ac{ANOBE} ciphertext be the tuple \((\VerifKey{}, C, \sigma)\), 
where
\(C = ( c_{\pi(1)}, \ldots, c_{\pi({|S|})})\) and
\(\sigma = \S*[Sign][\SignKey{}, C ]\).
Note that the signature does not authenticate the sender, it ties the 
ciphertext together and is needed for correctness.

\begin{frame}
  \begin{figure}
    \begin{algorithmic}
      \Function{$\ANOBEenc$}{$MPK, m, R$}
      \Comment{%
        Recipient set $R$,
        $m$ to be encrypted.
      }
        \State{%
          $(\SignKey{}, \VerifKey{})\rgets{\S*[Keygen][1^\lambda]}$
        }
        \Comment{%
          Signature key-pair, security parameter $\lambda$
        }
        \State{%
          Choose a random permutation \(\pi\colon R\to R\).
        }

        \For{$i \in R$}
          \State{%
            $c_{i}\gets{ \E*[Enc][\PubKey{i}, m\concat \VerifKey{}] }$
          }
        \EndFor{}

        \State{%
          $C\gets{( c_{\pi(1)}, \ldots, c_{\pi({|S|})} )}$
        }
        \State{%
          $\sigma\gets{ \S*[Sign][\SignKey{}, C] }$
        }
        \State{%
          \Return{$(\VerifKey{}, C, \sigma)$}
        }
      \EndFunction{}
    \end{algorithmic}
    \caption{%
      An algorithmic overview of the encryption algorithm in the \ac{ANOBE} 
      scheme.
    }\label{EncANOBE}
  \end{figure}
\end{frame}

We now have data which would like to decrypt.
We parse it as \((\VerifKey{}, C, \sigma)\).
If \(\S*[Verify][\VerifKey{}, C, \sigma ] = 0\), we return \(\bot\) as the 
verification failed.
For each \(c\) in \(C\):
Compute \(M = \E*[Dec][\PriKey{}, c ]\).
If \(M \neq \bot\) and \(M = (m, \VerifKey{})\), then return \(m\).
Otherwise, try the next \(c\).
If there are no more \(c\) to try, then return \(\bot\).

\begin{frame}
  \begin{figure}
    \begin{algorithmic}
      \Function{$\ANOBEdec$}{$MPK, \PriKey{}, C_{\ANOBE}$}
%      \Comment{%
%        Private key \(\PriKey{}\),
%        ciphertext $C_{\ANOBE} = (\VerifKey{}, C, \sigma)$.
%      }

        \If{$\S*[Verify][\VerifKey{}, C, \sigma ] = 0$}
          \State{%
            \Return{$\bot$}
          }
        \EndIf{}

        \For{$c\in C$}
          \State{%
            $M\gets{\E*[Dec][\PriKey{}, c]}$
          }
          \Comment{%
            Try to decrypt
          }
          \If{$M = \bot$}
            \State{\Return{$\bot$}}
          \ElsIf{$M = (m, \VerifKey{})$}
            \State{\Return{m}}
          \EndIf{}
        \EndFor{}
        \State{\Return{$\bot$}}
      \EndFunction{}
    \end{algorithmic}
    \caption{%
      An algorithmic overview of the decryption algorithm in the \ac{ANOBE} 
      scheme.
    }\label{DecANOBE}
  \end{figure}
\end{frame}

To decrypt an \ac{ANOBE} ciphertext, we need a trial-and-error decryption 
procedure to decide if the ciphertext was indeed intended for us.
This is costly as it makes the decryption function complexity \(O(|S|)\).
\citet{ANOBE} presented a tag-hint system along with their \ac{ANOBE} scheme.
The tag-hint system reduced the complexity back to \(O(1)\).
As this is not relevant for our discussion, we refer the reader to~\cite{ANOBE} 
but note that it can be used.

