\subsection{Sphinxes: the Sphinx header format Extended for Sets of nodes}%
\label{Sphinxes}

\Textcite{Sphinx} designed \iac{UC} secure message format for mixes, called 
Sphinx.
Since it is \ac{UC} secure, it provably implements an ideal onion routing 
functionality.
\Ie, it provides bitwise unlinkability on the forward route, hides the path 
length, makes replies indistinguishable from forward messages and resists 
tagging attacks.
It is also compact with only 224 bytes of header for a five-hop path with 
128-bit security.
Sphinx only provides one node per onion layer, in this section we extend Sphinx 
to Sphinxes, which allows for multiple nodes per onion layer.
(See \cref{fig:OR-POR}.)

\begin{figure}
  \includegraphics[width=\linewidth]{figures/OR-POR.png}
  \caption{\label{fig:OR-POR}%
    Illustration of the conceptual difference to traditional onion routing and 
    mixing.
  }
\end{figure}

\subsubsection{Overview of the Sphinx header format}

We will now give an overview of the Sphinx header format.
The idea is not to give a detailed description of Sphinx, but to to give the 
reader enough understanding of Sphinx to understand the changes we make to 
achieve Sphinxes.
For a more detailed understanding of Sphinx, we refer the reader to the 
excellent description in the original Sphinx paper~\cite{Sphinx}.

\NewVariable{\sk}{sk}
\NewVariable{\pk}{pk}

Each node \(n\) in the system has a long-term public-key pair: private key 
\(\sk_n\in \ZZ_q^*\) and public key \(\pk_n = g^{\sk_n}\in G\), where \(g\) 
generates a group \(G\) of prime order \(q\).

The Sphinx header (for the first node) is a triple \((\alpha_1, \beta_1, 
  \gamma_1)\), where \(\alpha_1\) is \iac{DHKE} exponent (\(g^x\), where \(x\) 
is a short-term secret chosen randomly for each header), \(\beta_1\) is the 
encrypted routing data and \(\gamma_1\) is \iac{MAC} for \(\beta_1\).
The payload data, \(\delta\), is treated separately from the header.

The first node in the path, with keys \((\pk_1, \sk_1)\), will compute the 
shared secret \(s_1 = \alpha_1^{\sk_1}\), \ie complete the \ac{DHKE} round.
Since \(\pk_1\) is an authenticated key, the sender can be sure that only this 
particular node can process the first layer of the onion.

The derived shared secret \(s_1\) is then used to derive various keys.
One of them is the key for the \ac{MAC} (\(gamma_1\)) to verify the integrity 
of the header (\(\beta_1\)).
If \(\beta_1\) is correct, another key is derived from \(s_1\) to decrypt 
\(\beta_1\) to get \(d_2\concat \gamma_2\concat \beta_2\), where \(d_2\) is the 
address of the second node in the path.

We note that \(\beta_i\) is encrypted using a stream cipher.
Thus we can append zeroes before decryption to keep the ciphertext length 
constant.
Since we append \emph{before} decryption, those appended zeroes will look 
completely random to the next node, thus the position on the path is hidden.

Finally, \(\alpha_1\) is blinded into \(\alpha_2\) with a key derived from 
\(s_1\).
Then the triple \((\alpha_2, \beta_2, \gamma_2)\) are sent to the node with 
address \(d_2\).

When node \(n\) discovers \(d_{n+1} = *\) it knows that the message is intended 
for itself and thus stops the forwarding.

\subsubsection{The Sphinxes extension for sets of nodes}

\NewAlgorithm{\Enc}{Enc}

We will now extend Sphinx to do \ac{POR}: instead of providing only \(d_{i+1}\) 
in \(\beta_i\), we will have a set \(\{d_{i+1}^{(0)}, \dotsc, d_{i+1}^{(m)}\}\) 
of \(m\) alternative next nodes.
This means that all \(m\) nodes must be able to compute the same shared secret 
\(s_{i+1}\).
We do this by adding one layer of indirection.

In Sphinx we denoted the public key for layer \(i\) as \(\pk_i\).
Since we have \(m\) alternative nodes with different keys, let us denote them 
by \(\pk_i^{(1)}, \dotsc, \pk_i^{(m)}\).

We extend the header to a quadruple \((\alpha_i, C_i, \beta_i, \gamma_i)\), 
where \(\alpha_i, \beta_i, \gamma_i\) are the same as before.
We let the shared secret \(s_i\) be chosen uniformly randomly instead of being 
computed as \(\alpha_i^{\sk_i}\).
We now compute one shared secret per alternative node, \ie \(s_i^{(j)} = 
  \alpha_i^{\sk_i^{(j)}}\) for \(1\leq j\leq m\).
Then \(C_i = c_i^{(1)}\concat \dotsb\concat c_i^{(m)}\) is the concatenation of 
ciphertexts \(c_i^{(j)} = \Enc[_{s_i^{(j)}}][s_i]\), where \(\Enc\) is 
\iac{SKE} algorithm and each ciphertext contains the shared secret \(s_i\) 
encrypted under the individual keys \(s_i^{(j)}\). 

When a node receives this new header, it will compute \(s_i^{(j)}\gets 
  \alpha_i^{\sk_i^{(j)}}\).
Then, it will try to decrypt each ciphertext component \(c_i^{(k)}\) of \(C_i\) 
to get \(\hat s_i\).
If \iac{MAC} key that successfully verifies \(\beta_i\) using \(\gamma_i\) can 
be derived from \(\hat s_i\), then the node knows that \(\hat s_i = s_i\).


\subsubsection{Sphinxes algorithms and \acf*{POR}}

\NewScheme{\Sphinxes}{Sphxs}
\NewAlgorithm{\CreateHeader}{\Sphinxes[CreateHeader]}
\NewAlgorithm{\CreateFwd}{\Sphinxes[CreateFwd]}
\NewAlgorithm{\CreateRe}{\Sphinxes[CreateReply]}
\NewAlgorithm{\WrapRe}{\Sphinxes[WrapReply]}
\NewAlgorithm{\Process}{\Sphinxes[Process]}

Sphinxes provides the following algorithms:
\begin{itemize}
  \item \(\CreateHeader\) creates a header, this is a modification of that of 
    Sphinx~\cite[\S 3.2]{Sphinx};
  \item \(\CreateFwd\) creates a forward message, this is identical to that of 
    Sphinx~\cite[\S 3.3]{Sphinx};
  \item \(\CreateRe\) creates a single-use reply block, it is the same as in 
    Sphinx~\cite[\S 3.4]{Sphinx} except that it also outputs the necessary keys 
    to wrap it;
  \item \(\WrapRe\) is used to wrap a given single-use reply block; finally
  \item \(\Process\) is the algorithm for processing incoming messages, the 
    processing is identical to Sphinx~\cite[\S 3.6, \S 3.7]{Sphinx} but uses a 
    different interface.
\end{itemize}

\NewAlgorithm{\ExtendRoute}{ExtendRoute}
\NewAlgorithm{\CreateOnionLayer}{CreateOnionLayer}

\begin{figure}
  \framebox{\begin{minipage}{0.96\linewidth}
  \begin{algorithmic}[1]
    \Require{%
      $H$ is a header of the form \(D\concat H'\) or \(D\concat \top\), where 
      \(D\) is a set of device addresses.
      $\pk_D$ is the public key of device set $D$.
      $L$ is the length of the route,
      $\theta$ is the threshold of probability of failure.%
    }
    \Function{\ExtendRoute}{$H, L, \theta$}
      \If{$L\leq 0$}
        \State \Return $H$
      \EndIf
      \State $D\gets \CreateOnionLayer[\theta]$
      \State $H\gets D\concat \DeBEenc[\mpk, D, H]$
      \State \Return $\ExtendRoute[H, L-1, \theta]$
    \EndFunction

    \Function{\CreateOnionLayer}{$\theta$}
      \State $(d, \pk_d, p_d)\gets \GetRandomPeer$
      \State $D\gets \{(d, \pk_d, p_d)\}$
      \While{$\prod_{d\in D} p_d > \theta$}
        \State $(d, \pk_d, p_d)\gets \GetRandomPeer$
        \State $D\gets D\cup \{(d, \pk_d, p_d)\}$
      \EndWhile
      \State \Return $D$
    \EndFunction
  \end{algorithmic}
  \end{minipage}}
  \caption{\label{ExtendRoute}%
    The \(\ExtendRoute\) algorithm extends a route \(H\) with \(L\) hops and 
    failure threshold of \(\theta\) for each hop in the route.
    Thus the probability of failure for the extension is \(1 - (1 - \theta)^L\).
    The function \(\GetRandomPeer\) is any random peer-sampling algorithm.
  }
\end{figure}


