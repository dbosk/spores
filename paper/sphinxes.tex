\section{Sphinxes: the Sphinx header format Extended for Sets of nodes}%
\label{Sphinxes}

\Textcite{Sphinx} designed \iac{UC} secure message format for mixes, called 
Sphinx.
Since it is \ac{UC} secure, it provably implements an ideal onion routing 
functionality.
\Ie, it provides bitwise unlinkability on the forward route, hides the path 
length, makes replies indistinguishable from forward messages and resists 
tagging attacks.
It is also compact with only 224 bytes of header for a five-hop path with 
128-bit security.
Sphinx only provides one node per onion layer, in this section we extend Sphinx 
to Sphinxes, which allows for multiple nodes per onion layer.

\subsection{Overview of the Sphinx header format}

We will now give an overview of the Sphinx header format.
The idea is not to give a detailed description of Sphinx, but to to give the 
reader enough understanding of Sphinx to understand the changes we make to 
achieve Sphinxes.
For a more detailed understanding of Sphinx, we refer the reader to the 
excellent description in the original Sphinx paper~\cite{Sphinx}.

\NewVariable{\sk}{sk}
\NewVariable{\pk}{pk}

Each node \(n\) in the system has a long-term public-key pair: private key 
\(\sk_n\in \ZZ_q^*\) and public key \(\pk_n = g^{\sk_n}\in G\), where \(g\) 
generates a group \(G\) of prime order \(q\).

The Sphinx header (for the first node) is a triple \((\alpha_1, \beta_1, 
  \gamma_1)\), where \(\alpha_1\) is \iac{DHKE} exponent (\(g^x\), where \(x\) 
is a short-term secret chosen randomly for each header), \(\beta_1\) is the 
encrypted routing data and \(\gamma_1\) is \iac{MAC} for \(\beta_1\).
The payload data, \(\delta\), is treated separately from the header.

The first node in the path, with keys \((\pk_1, \sk_1)\), will compute the 
shared secret \(s_1 = \alpha_1^{\sk_1}\), \ie complete the \ac{DHKE} round.
Since \(\pk_1\) is an authenticated key, the sender can be sure that only this 
particular node can process the first layer of the onion.

The derived shared secret \(s_1\) is then used to derive various keys.
One of them is the key for the \ac{MAC} (\(gamma_1\)) to verify the integrity 
of the header (\(\beta_1\)).
If \(\beta_1\) is correct, another key is derived from \(s_1\) to decrypt 
\(\beta_1\) to get \(d_2\concat \gamma_2\concat \beta_2\), where \(d_2\) is the 
address of the second node in the path.

We note that \(\beta_i\) is encrypted using a stream cipher.
Thus we can append zeroes before decryption to keep the ciphertext length 
constant.
Since we append \emph{before} decryption, those appended zeroes will look 
completely random to the next node, thus the position on the path is hidden.

Finally, \(\alpha_1\) is blinded into \(\alpha_2\) with a key derived from 
\(s_1\).
Then the triple \((\alpha_2, \beta_2, \gamma_2)\) are sent to the node with 
address \(d_2\).

When node \(n\) discovers \(d_{n+1} = *\) it knows that the message is intended 
for itself and thus stops the forwarding.

\subsection{The Sphinxes extension for sets of nodes}

\NewAlgorithm{\Enc}{Enc}

We will now extend Sphinx: instead of providing only \(d_{i+1}\) in 
\(\beta_i\), we will have a set \(\{d_{i+1}^{(0)}, \dotsc, d_{i+1}^{(m)}\}\) of 
\(m\) alternative next nodes.
This means that all \(m\) nodes must be able to compute the same shared secret 
\(s_{i+1}\).
We do this by adding one layer of indirection.

In Sphinx we denoted the public key for layer \(i\) as \(\pk_i\).
Since we have \(m\) alternative nodes with different keys, let us denote them 
by \(\pk_i^{(1)}, \dotsc, \pk_i^{(m)}\).

We extend the header to a quadruple \((\alpha_i, C_i, \beta_i, \gamma_i)\), 
where \(\alpha_i, \beta_i, \gamma_i\) are the same as before.
We let the shared secret \(s_i\) be chosen uniformly randomly instead of being 
computed as \(\alpha_i^{\sk_i}\).
We now compute one shared secret per alternative node, \ie \(s_i^{(j)} = 
  \alpha_i^{\sk_i^{(j)}}\) for \(1\leq j\leq m\).
Then \(C_i = c_i^{(1)}\concat \dotsb\concat c_i^{(m)}\) is the concatenation of 
ciphertexts \(c_i^{(j)} = \Enc[_{s_i^{(j)}}][s_i]\), where \(\Enc\) is 
\iac{SKE} algorithm and each ciphertext contains the shared secret \(s_i\) 
encrypted under the individual keys \(s_i^{(j)}\). 
