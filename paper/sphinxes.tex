\subsection{Sphinxes: the Sphinx header format Extended for Sets of nodes}%
\label{Sphinxes}

\Textcite{Sphinx} designed \iac{UC} secure message format for mixes, called 
Sphinx.
Since it is \ac{UC} secure, it provably implements an ideal onion routing 
functionality.
\Ie, it provides bitwise unlinkability on the forward route, hides the path 
length, makes replies indistinguishable from forward messages and resists 
tagging attacks.
It is also compact with only 224 bytes of header for a five-hop path with 
128-bit security.
Sphinx only provides one node per onion layer, in this section we extend Sphinx 
to Sphinxes, which allows for multiple nodes per onion layer.
(See \cref{fig:OR-POR}.)

\begin{figure}
  \includegraphics[width=\linewidth]{figures/OR-POR.png}
  \caption{\label{fig:OR-POR}%
    Illustration of the conceptual difference to traditional onion routing and 
    mixing.
  }
\end{figure}

\subsubsection{Overview of the Sphinx header format}

We will now give an overview of the Sphinx header format.
The idea is not to give a detailed description of Sphinx, but to to give the 
reader enough understanding of Sphinx to understand the changes we make to 
achieve Sphinxes.
For a more detailed understanding of Sphinx, we refer the reader to the 
excellent description in the original Sphinx paper~\cite{Sphinx}.

\NewVariable{\sk}{x}
\NewVariable{\pk}{X}

Each node \(n\) in the system has a long-term public-key pair: private key 
\(\sk_n\in \ZZ_q^*\) and public key \(\pk_n = g^{\sk_n}\in G\), where \(g\) 
generates a group \(G\) of prime order \(q\).

The Sphinx header (for the first node) is a triple \((\alpha_1, \beta_1, 
  \gamma_1)\), where \(\alpha_1\) is \iac{DHKE} exponent (\(g^x\), where \(x\) 
is a short-term secret chosen randomly for each header), \(\beta_1\) is the 
encrypted routing data and \(\gamma_1\) is \iac{MAC} for \(\beta_1\).
The payload data, \(\delta\), is treated separately from the header.

The first node in the path, with keys \((\pk_1, \sk_1)\), will compute the 
shared secret \(s_1 = \alpha_1^{\sk_1}\), \ie complete the \ac{DHKE} round.
Since \(\pk_1\) is an authenticated key, the sender can be sure that only this 
particular node can process the first layer of the onion.

The derived shared secret \(s_1\) is then used to derive various keys.
One of them is the key for the \ac{MAC} (\(gamma_1\)) to verify the integrity 
of the header (\(\beta_1\)).
If \(\beta_1\) is correct, another key is derived from \(s_1\) to decrypt 
\(\beta_1\) to get \(d_2\concat \gamma_2\concat \beta_2\), where \(d_2\) is the 
address of the second node in the path.

We note that \(\beta_i\) is encrypted using a stream cipher.
Thus we can append zeroes before decryption to keep the ciphertext length 
constant.
Since we append \emph{before} decryption, those appended zeroes will look 
completely random to the next node, thus the position on the path is hidden.

Finally, \(\alpha_1\) is blinded into \(\alpha_2\) with a key derived from 
\(s_1\).
Then the triple \((\alpha_2, \beta_2, \gamma_2)\) are sent to the node with 
address \(d_2\).

When node \(n\) discovers \(d_{n+1} = *\) it knows that the message is intended 
for itself and thus stops the forwarding.

\subsubsection{The Sphinxes extension for sets of nodes}

\NewAlgorithm{\Enc}{Enc}

We will now extend Sphinx to do \ac{POR}: instead of providing only \(d_{i+1}\) 
in \(\beta_i\), we will have a set \(\{d_{i+1}^{(0)}, \dotsc, d_{i+1}^{(m)}\}\) 
of \(m\) alternative next nodes.
This means that all \(m\) nodes must be able to compute the same shared secret 
\(s_{i+1}\).
We do this by adding one layer of indirection.

In Sphinx we denoted the public key for layer \(i\) as \(\pk_i\).
Since we have \(m\) alternative nodes with different keys, let us denote them 
by \(\pk_i^{(1)}, \dotsc, \pk_i^{(m)}\).

We extend the header to a quadruple \((\alpha_i, C_i, \beta_i, \gamma_i)\), 
where \(\alpha_i, \beta_i, \gamma_i\) are the same as before.
We let the shared secret \(s_i\) be chosen uniformly randomly instead of being 
computed as \(\alpha_i^{\sk_i}\).
We now compute one shared secret per alternative node, \ie \(s_i^{(j)} = 
  \alpha_i^{\sk_i^{(j)}}\) for \(1\leq j\leq m\).
Then \(C_i = c_i^{(1)}\concat \dotsb\concat c_i^{(m)}\) is the concatenation of 
ciphertexts \(c_i^{(j)} = \Enc[_{s_i^{(j)}}][s_i]\), where \(\Enc\) is 
\iac{SKE} algorithm and each ciphertext contains the shared secret \(s_i\) 
encrypted under the individual keys \(s_i^{(j)}\). 

When a node receives this new header, it will compute \(s_i^{(j)}\gets 
  \alpha_i^{\sk_i^{(j)}}\).
Then, it will try to decrypt each ciphertext component \(c_i^{(k)}\) of \(C_i\) 
to get \(\hat s_i\).
If \iac{MAC} key that successfully verifies \(\beta_i\) using \(\gamma_i\) can 
be derived from \(\hat s_i\), then the node knows that \(\hat s_i = s_i\).


\subsubsection{Sphinxes algorithms and \acf*{POR}}

\NewScheme{\Sphinxes}{POR}
\NewAlgorithm{\CreateHeader}{\Sphinxes[CreateHeader]}
\NewAlgorithm{\CreateFwd}{\Sphinxes[CreateForward]}
\NewAlgorithm{\CreateReply}{\Sphinxes[CreateReply]}
\NewAlgorithm{\UseReply}{\Sphinxes[UseReply]}
\NewAlgorithm{\ProcessHeader}{\Sphinxes[ProcessHeader]}

Sphinxes provides the following algorithms:
\begin{itemize}
  \item \(\CreateHeader\) creates a header.

  \item \(\CreateFwd\) constructs a header to be used for forward messages.

  \item \(\CreateReply\) constructs a header to be used for replies.

  \item \(\UseReply\) takes a reply header and attaches a message.

  \item \(\ProcessHeader\) is the algorithm for processing incoming messages, 
    the processing is identical to Sphinx~\cite[\S 3.6, \S 3.7]{Sphinx} but 
    uses a different interface.
\end{itemize}

\NewVariable{\G}{\mathcal{G}}
\NewVariable*{\mac}{\mu}
\NewVariable*{\prg}{\rho}
\NewVariable*{\prp}{\pi}
\NewVariable{\hash}{h}
%\NewVariable{\tag}{\tau}
\NewVariable{\secret}{s}
\NewVariable{\blind}{b}
\NewVariable{\N}{\mathcal{N}}
\NewVariable{\D}{\mathcal{D}}
\NewVariable*{\nullnode}{\varepsilon}
\NewVariable{\rdvnode}{*}

We will synchronize our detailed descriptions with that of 
Sphinx~\cite{Sphinx}, hence we will use the following notation:
\begin{itemize}
  \item \(\kappa\) is the security parameter.
    The adversary must thus do about \(2^\kappa\) work to break the security.

  \item \(r\) is the maximum number of nodes (\ie equivalent to the number of 
    layers) that a message will traverse before reaching its destination.

  \item \(\G\) is a prime-order cyclic group satisfying the \ac{DH} assumption.

  \item \(\mac\colon \bin^\kappa\times \bin^*\to \bin^\kappa\) is \iac{MAC}.
    It can be instantiated as \eg SHA256-HMAC-128.

  \item \(\prg\colon \bin^\kappa\to \bin^{(2r+3)\kappa}\) is \iac{PRG}.
    It can be instantiated as any block cipher in counter mode.

  \item \(\prp\colon \bin^\kappa\times \bin^{l_\prp} \to \bin^{l_\prp}\) is 
    \iac{PRP}.
    It can be instantiated using the LIONESS block cipher~\cite{LIONESS}.

  \item \(\hash_\mac, \hash_\prg, \hash_\prp\) are all distinct hash functions 
    of the form \(\bin^\kappa\to \bin^\kappa\).
    They are used as key-derivation functions.

  \item \(\hash_\tau\colon \G^*\to \bin^{2\kappa}\) is used to identify 
    previously seen elements of \(\G^*\).

  \item \(\hash_\blind\colon \G^*\times \G^*\to \ZZ_q^*\) is used to compute 
    blinding factors.
    All the hash functions can be instantiated with truncated versions of hash 
    functions from the SHA-2 and -3 families.

  \item \(\N\subset \bin^\kappa\) is a set of node identifiers.
    Each node \(n\in \N\) has a private key \(\sk_n\in \ZZ_q^*\) and a public 
    key \(\pk_n = g^{\sk_n}\in \G^*\).
    We assume that the identifier--public-key pairs, \((n, \pk_n)\), are 
    distributed.
    (Sphinx made a difference between nodes and destinations, \ie the set 
    \(\D\) such that \(\D\cap \N = \emptyset\) and \(\D\cup \N\) is prefix 
    free, see~\cite{Sphinx} for details.
    We could do the same adoption, but we do not need that for the purposes of 
    this paper.)
    We have two special node identifiers:
    \(\nullnode\in \N\) is the null-node identifier, indicating an empty 
    address.
    \(\rdvnode\in \N\) is the rendezvous-node identifier, indicating that the 
    current node is a rendezvous node and that the payload is \iac{POR} route 
    to forward.

  \item \(0_x\) denotes \(x\) zeroes.
    \(s_{[a..b]}\) denotes all bits from the \(a\)th bit to the \(b\)th of the 
    bit string \(s\).
\end{itemize}

\paragraph*{The \(\CreateHeader\) algorithm}

\NewAlgorithm{\ComputeKeys}{ComputeKeys}
\NewAlgorithm{\ComputePadding}{ComputePadding}

This algorithm creates a header for \iac{POR}.
It is identical to that of Sphinx~\cite[\S 3.2]{Sphinx} except that we use a 
set of addresses and keys for each layer instead of only one address and key.
Also, we do not distinguish between addresses of destinations and routers.

The algorithm takes as input a unique identifier \(I\in \bin^\kappa\) and a set 
of layers \(L = \{L_0, \dotsc, L_\nu\}\) such that \(\nu+1\leq r\).
The last layer, \(L_\nu\), should be either \(\{\nullnode\}\) or 
\(\{\rdvnode\}\) to terminate the routing.

We let \(w_L = \max_{N\in L}|N|\) be the maximum width of a layer, \ie the 
number of alternative nodes in the layer with the most alternative nodes.
We let \(w_H = 2w_L+1\) be the header width:
each layer must accommodate the layer nodes' ciphertexts and addresses, \ie  
\(2w_L\) elements of \(\kappa\) bits,
and the \ac{MAC}, \ie one element of \(\kappa\) bits.
(Note that we reveal the maximum number of alternatives per layer, but this is 
no different from ordinary \ac{OR} where there is a constant one node per 
layer.)

First we generate all the needed keys.
We compute \(\nu+1\) tuples
\begin{align*}
  \alpha_0 &\gets g^\sk,
  & \secret_0 &\gets \bin^\kappa,
  & \blind_0 &\gets \hash_\blind(\alpha_0, \secret_0) \\
  \alpha_1 &\gets g^{\sk\blind_0},
  & \secret_1 &\gets \bin^\kappa,
  & \blind_1 &\gets \hash_\blind(\alpha_1, \secret_1) \\
  &\vdots &&\vdots && \vdots \\
  \alpha_\nu &\gets g^{\sk \blind_0\dotsb \blind_{\nu-1}},
  & \secret_\nu &\gets \bin^\kappa,
  & \blind_\nu &\gets \hash_\blind(\alpha_\nu, s_\nu).
\end{align*}
In addition, we compute
\begin{align*}
  \secret_0^{(0)} &\gets \pk_{n_0^{(0)}}^\sk,
  & \dotsc, &
  & \secret_0^{(|L_0|-1)} &\gets \pk_{n_0^{(|L_0|-1)}}^\sk \\
  \secret_1^{(0)} &\gets \pk_{n_1^{(0)}}^{\sk \blind_0},
  & \dotsc, &
  & \secret_1^{(|L_1|-1)} &\gets \pk_{n_1^{(|L_1|-1)}}^{\sk \blind_0} \\
  & \vdots &&& \vdots \\
  \secret_\nu^{(0)} &\gets \pk_{n_\nu^{(0)}}^{\sk \blind_0\dotsb 
    \blind_{\nu-1}},
  & \dotsc, &
  & \secret_\nu^{(|L_\nu|-1)} &\gets \pk_{n_\nu^{(|L_\nu|-1)}}^{\sk 
    \blind_0\dotsb \blind_{\nu-1}}.
\end{align*}
We note that a node \(n_i^{(j)}\) can compute \(s_i^{(j)}\) since \[
  s_i^{(j)} = \pk_{n_i^{(j)}}^{\sk \blind_0\dotsb \blind_{i-1}} = 
  \alpha_i^{\sk_{n_i^{(j)}}}.
\]
We then construct the ciphertexts
\begin{align*}
  C_0 &= \prp'\left(\hash_{\prp'}\left(s_0^{(0)}\right), s_0\right)
  \concat \dotsb
  \concat \prp'\left(\hash_{\prp'}\left(s_0^{(|L_0|-1)}\right), s_0\right) \\
  C_1 &= \prp'\left(\hash_{\prp'}\left(s_1^{(0)}\right), s_1\right)
  \concat \dotsb
  \concat \prp'\left(\hash_{\prp'}\left(s_1^{(|L_1|-1)}\right), s_1\right) \\
  & \vdots \\
  C_\nu &= \prp'\left(\hash_{\prp'}\left(s_\nu^{(0)}\right), s_\nu\right)
  \concat \dotsb
  \concat \prp'\left(\hash_{\prp'}\left(s_\nu^{(|L_\nu|-1)}\right) 
    s_\nu\right).
\end{align*}
and pad them to equal length with uniformly random bits, \ie length \(w_L = 
  \max_{i\in \{0, \dotsc, \nu\}} |C_i|\), where \(|C_i|\) denotes the length in 
bits (each ciphertext is \(\kappa\) bits).
These computations are summarized in \cref{fig:SphinxesKeys}.
\commentDaniel{We can probably comment out the figure.}

\begin{figure}
  \framebox{\begin{minipage}{0.96\linewidth}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{\ComputeKeys}{$L = \{L_0, \dotsc, L_l\}, w_L$}
      \State $\sk\rgets \ZZ_q^*, \pk\gets g^\sk$
      \State $\alpha_0\gets \pk$
      \State $s_0\rgets \bin^\kappa$
      \For{$1\leq i\leq |N_0|$}
        \State $s_0^{(i)}\gets \pk_{n_i}^\sk$, where $n_i\in |N_0|$.
        \State $c_0^{(i)}\gets \Enc[_{s_0^{(i)}}][s_0]$
      \EndFor
      \For{$|N_0|+1\leq i\leq w_L$}
        \State $c_0^{(i)}\rgets \bin^\kappa$
      \EndFor
      \State $C_0\gets (c_0^{(1)}, \dotsc, c_0^{(w)})$
      \State $b_0\gets \hash_\blind(\alpha_0, s_0)$
      \For{$1\leq i < \nu$}
        \State Compute $(\alpha_i, C_i, \beta_i, \gamma_i)$ as follows.
        \State $\alpha_i = \pk^{b_{i-1}}$
        \State $s_i\rgets \bin^\kappa$
        \For{$1\leq j\leq |N_i|$}
          \State $s_i^{(j)}\gets \pk_{n_j}^\sk$, where $n_j\in |N_i|$.
          \State $c_i^{(j)}\gets \Enc[_{s_i^{(j)}}][s_i]$
        \EndFor
        \For{$|N_i|+1\leq i\leq w_L$}
          \State $c_0^{(i)}\rgets \bin^\kappa$
        \EndFor
        \State $C_i\gets (c_i^{(1)}, \dotsc, c_i^{(w)})$
        \State $b_i\gets \hash_\blind(\alpha_i, s_i)$
      \EndFor
      \State \Return $(\alpha_0, s_0, C_0, b_0), \dotsc, (\alpha_\nu, s_\nu, 
      C_\nu, b_\nu)$
    \EndFunction
  \end{algorithmic}
  \end{minipage}}
  \caption{\label{fig:SphinxesKeys}%
    A function computing the keys for all nodes on all layers of a route.
    \(L = \{L_i\}_i\) is the set of layers and each \(L_i\) is a set of the 
    nodes on that layer.
    \(w_L = \max_{L_i\in L} |L_i|\) is the maximum layer width, \ie the number 
    of nodes in the layer with most nodes.
  }
\end{figure}

Next we need to compute the padding \(\phi_i\) for each layer \(i\).
We must do this is to predict the padding introduced at each layer so that we 
can compute the correct \acp{MAC} (\(\gamma_i\)).
The padding for the outmost layer (layer 0) is the empty string, thus \(\phi_0 
  \gets \epsilon\).
Then, for layers \(1\leq i\leq \nu\), we get
\begin{multline*}
  \phi_i\gets \left\{\phi_{i-1}\concat 0_{w_H\kappa}\right\}\oplus \\
  \left\{\prg\left(\hash_\prg\left(s_{i-1}\right)\right)_{[(w_H(r-i)+3)\kappa..(2r+3)\kappa-1]}\right\}.
\end{multline*}
These computations are summarized in \cref{fig:SphinxesPadding}.
\commentDaniel{We can probably remove the figure.}

\begin{figure}
  \framebox{\begin{minipage}{0.96\linewidth}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{\ComputePadding}{$\{s_0, \dotsc, s_\nu\}, w_H$}
      \State $\phi_0\gets \epsilon$
      \Comment{$\epsilon$ is the empty string.}
      \For{$1\leq i\leq \nu$}
        \State $\phi_i = \{ \phi_{i-1}\concat 0_{w_H} \} \oplus
          \{ \prg(\hash_\prg(s_{i-1}))_{[(w_H(r-i)+3)\kappa..(w_H 
            r+3)\kappa-1]} \}$
      \EndFor
      \State \Return $\phi_0, \dotsc, \phi_\nu$
    \EndFunction
  \end{algorithmic}
  \end{minipage}}
  \caption{\label{fig:SphinxesPadding}%
    A function computing the needed padding.
    \(\{s_i\}_i\) is the set of keys for the layers.
    \(w_H\) is the width of the header at each layer, \ie everything that must 
    be removed and compensated by padding.
  }
\end{figure}

Next we will use the above computations to compute the mix headers \(M_i = 
  (\alpha_i, \beta_i, \gamma_i)\).
\(\alpha_i\) was computed above, so we will compute \(\beta_i\) and 
\(\gamma_i\).
We must compute \(\beta_i\) in reverse order.
We let \(\beta_{\nu+1} = I\concat 0_{(w_H r-1)\kappa}\), then, for \(\nu\leq 
  i\leq 0\), we let
\begin{align*}
  \beta_i &\gets \left\{L_{i+1}\concat \gamma_{i+1}\concat 
    (\beta_{i+1})_{[0..(w_H r-1)\kappa-1]}\right\}, \\
  \gamma_i &\gets \mac\left( \hash_\mac\left(s_i\right), \beta_i \right).
\end{align*}
The algorithm \(\CreateHeader\) is summarized in \cref{fig:CreateHeader}.
\commentDaniel{We can probably remove the figure.}

\begin{figure}
  \framebox{\begin{minipage}{0.96\linewidth}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{\CreateHeader}{$I, L = \{L_i\}_i$}
      \State $w_L\gets \max_{L_i\in L} |L_i|$
      \Comment{Layer width}
      \State $w_H\gets (2w_L+1)$
      \Comment{Header width}
      \State $(\alpha_0, s_0, C_0, b_0), \dotsc, (\alpha_\nu, s_\nu, C_\nu, 
      b_\nu)\gets \ComputeKeys[L, w_L]$
      \State $\phi_0, \dotsc, \phi_\nu\gets \ComputePadding[\{s_0, \dotsc, 
      s_\nu\}, w_H]$
      \State $\alpha \gets \alpha_\nu$
      \State $C\gets C_\nu$
      \State $\beta \gets
        \left\{\left\{L_\nu\concat
            I\concat
            0_{(2w_L(r-\nu)+2)\kappa}\right\} \oplus
          \prg(\hash_\prg(s_\nu)_{[0..(2w_L(r-\nu)+3)\kappa-1]}\right\}\concat 
        \phi_\nu$
      \Comment{$\beta_\nu$}
      \State $\gamma \gets \mac(\hash_\mac(s_\nu), \beta)$
      \Comment{$\gamma_\nu$}
      \For{$\nu-1\leq i\leq 0$}
          \State $\beta_i \gets \{L_{i+1}, \concat \gamma_{i+1}\concat 
          (\beta_{i+1})_{[0..(w_L r-1)\kappa -1]}\}$
          \State $\gamma_i \gets \mac(\hash_\mac(s_i), \beta_i)$
      \EndFor
      \State \Return $(\alpha, C, \beta, \gamma), \{s_0, \dotsc, s_\nu\}$
    \EndFunction
  \end{algorithmic}
  \end{minipage}}
  \caption{\label{fig:CreateHeader}%
    \dots
      $I\in \bin^\kappa$ is an identifier.
      $L = \{L_0, \dotsc, L_\nu\}$ such that $L_i, L_j\subset \N$, $L_i\cap L_j 
      = \emptyset\}$ for $i\neq j$, and $\nu+1 = |L| \leq r$.
      $L_\nu$ is the destination.
  }
\end{figure}

\paragraph*{The \(\CreateFwd\) algorithm}

This algorithm computes a forward header with a message to be delivered to the 
destination.
It takes as input a sequence, \(L = \{L_0, \dotsc, L_\nu\}\), of node sets, 
such that \(\nu+1\leq r\) and \(L_\nu\) is either \(\{\nullnode\}\) or 
\(\{\rdvnode\}\), and a message \(m\).
(\Ie \(L_{\nu-1}\) is the final destination.)

It first runs \(\CreateHeader\) with \(I = 0_\kappa\) to compute a mix header 
\(M_0\) and the keys \(s_i\) for each layer \(i\).
Then, for \(\nu\leq i\leq 0\), it will compute
\begin{equation*}
  \delta_i = \prp\left(
    \hash_\prp\left(s_i\right),
    \delta_{i+1}\right),
\end{equation*}
where \(\delta_{\nu+1}\) is the message \(m\).

\paragraph*{The \(\CreateReply\) algorithm}

This algorithm prepares a header that can be used for anonymous replies.
It takes as input a sequence, \(L = \{L_0, \dotsc, L_\nu\}\), of node sets, 
such that \(\nu+1\leq r\), \(L_\nu\) is either \(\{\nullnode\}\) or 
\(\{\rdvnode\}\) and \(L_{\nu-1}\) is the set of own addresses.

It first runs \(\CreateHeader\) with \(I\rgets \bin^\kappa\) to compute a mix 
header \(M_0\) and the keys \(s_i\) for each layer \(i\).
It chooses uniformly randomly a key \(\tilde k\rgets \bin^\kappa\).
Finally, it returns
\(I\),
the tuple of keys \((\tilde k, \hash_\prp(s_0), \dotsc, \hash_\prp(s_\nu))\),
and \((L_0, M_0, \tilde k)\).

The tuple of keys must be stored in a local table indexed by \(I\).
The tuple \((L_0, M_0, \tilde k)\) should be given to the sender who wants to 
use the anonymous reply.

\paragraph*{The \(\UseReply\) algorithm}

This algorithm takes a reply header \((L_0, M_0, \tilde k)\) and a message 
\(m\) as input.
It then returns \((M_0, \prp(\tilde k, m))\) which should be sent to any node 
in \(L_0\).

\paragraph*{The \(\ProcessHeader\) algorithm}

\dots
