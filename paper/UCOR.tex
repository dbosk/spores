\section{\Acladj*{UC} \acl*{OR}}%
\label{UCOR}
The \ac{UC} framework is a mathematical framework that can be summarized in
two ideas, first, that there exists a stringent and well defined idea
about what a protocol needs to do, its functionality. Secondly, that
any two protocols that fulfill this idea should be {\it
  indistinguishable\/} in the sense that they should perform the exact
same service~\cite{UniversalComposability}. If the protocol is regarded as a black box, this means
that any input into the two different boxes should result in the
exact same output.

The second idea also means that any two protocols, with well defined
functionalities, should not interefere with one another if they are
are used in parallel or one after the other, as long as their inputs
are correct. That is, they are composable~\cite{UniversalComposability}.

The underlying framework is quite technical and requires one to handle
a computational model with what the original author %TODO: Insert reference
called Interactive Turing Machines and on top of this designed the
Universal Composability theorem \cite{UniversalComposability}. However, the most important part of
this framework is what is known as an {\bf Ideal Functionality}, which
can be thought of as a black box that fulfills some well-defined
functionality\cite{UniversalComposability}. The idea behind the \ac{UC} framework is then that we ought
to define a protocol which we must then prove simulates the ideal
functionality, so that distinghuising between the ideal functionality
and the real protocol becomes infeasible.

However, this is not necessarily the way one must go about working in
the framework. We will, for example, instead utilise the fact that one
may prove some sufficient conditions that if fulfilled means that the
protocol must simulate the ideal functionality.

One of the first successful uses of the \ac{UC} framework was a model
created by Jan Camenish and Anna Lysyanskaya (a mode we will call the
CL-model). This model was an attempt at formalising the concept of
onion routing using the UC-framework. It relied on an ideal
functionality, and 5 properties that ensured a protocol would properly
simulate the ideal functionality~\cite{CL-model}.

The ideal functionality itself works through messages, and is
designed around 4 different functions, each activated by a specific
message~\cite{CL-model}.
\begin{itemize}
  \item{{\tt Process_New_Onion} When an onion is received, either
    reject if faulty or proceed with}
  \item{{\tt Process_Next_Step} Creates a temporary id for the onion
    and informs the adversary of onion (this emulates the fact that
    the adversary controls the network). If the router itself is
    adversial, it also tells the adversary which route it was part
    of. }
  \item{{\tt Deliver_Message} Is actually sent by the adversary, but
    simply informs the router to send the onion to the next step in
    its path.}
  \item{{\tt Forward_Onion} Tells the ideal functionality to send the
    message to the next router and the step {\tt Process_Next_Step} is
    once again taken.}
\end{itemize}

To prove that a protocol properly simulates this ideal functionality,
the CL-model, as mentioned above, defined five sufficient properties~\cite{CL-model}.

\begin{enumerate}
  \item{{\bf Onion routing scheme I/O.} The protocol should have a key
  generation algorithm for asymetric encryption, be able to form an
  onion from a message and a list of routers and their public
  keys. Lastly, the protocol should also be able to process the onion,
  that is, peel a layer off of it and deliver it to the next router.}

  \item{{\bf Onion evolution, path and layering.} Each onion should
    have a pair of idenifiers, that is the onion itself and its
    router. Then the evolution is the ordered set of such pairs, the path is
    the set of routers and the layering is the set of onions.}

  \item{{\bf Onion-correctness.} This is the simple condition that if a
  correctly formed onion is processed correctly and by the correct
  routers, then the correct message is received by the last router.}

  \item{{\bf Onion-integrity.} This is the requirement that the path of
  an onion is limited by some integer N, that is, no matter how an
  onion is manipulated, the path may never have a length that is
  larger than N.}

  \item{{\bf Onion-security.} A protocol has the property of
    onion-security if an adversary can not guess the message nor add
    an extra onion-layer to any onion.}
\end{enumerate}


However, while these definitions are useful, newer work have found
that they were not sufficient and added two new properties, which has
since been proven to fulfill the security properties of the ideal
functionality~\cite{kuhn}. The properties were:

\begin{enumerate}
  \setcounter{enumi}{5}
  \item{{\bf Tail indistinguishability against a corrupted receiver.}
    An adversary that reads after the last honest relay should not be
    able to distinguish between two onions who follow the same path
    after the last honest router, but differ before it.}

  \item{{\bf Layer-Unlinkability against bypassing honest nodes.} An
    adversary should not be able to distinguish between an onion for
    which the adversary chooses the path up to an honest router, and
    an onion which contains this path as a subpath.}
\end{enumerate}

With these properties and the SphinxES protocol, we wish to prove that
SphinxES does indeed have these properties, and thus fulfills the
security properties of the ideal functionality. 
